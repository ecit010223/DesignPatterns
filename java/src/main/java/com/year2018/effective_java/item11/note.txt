谨慎地覆盖clone
既然Cloneable并没有包含任何方法，那么它到底有什么作用呢？它决定了Object中受保护的clone方法实现的行为：
如果一个类实现了Cloneable，Object的clone方法就返回该对象的逐域拷贝，否则就会抛出
CloneNotSupportedException异常。这是接口的一种极端非典型的用法，也不值得仿效。通常情况下，实现接口是为
了表明类可以为它的客户做些什么。然而，对于Cloneable接口，它改变了超类中受保护的方法的行为。
如果实现Cloneable接口是要对某个类起到作用，类和它的所有超类都必须遵守一个相当复杂、不可实施的，并且基本
上没有文档说明的协议。由此得到一种语言之外的机制：无需调用构造器就可以创建对象。
拷贝对象往往会导致创建它的类的一个新实例，但它同时也会以要求拷贝内部的数据结构，这个过程中没有调用构造器。
克隆复杂对象的最后一种办法是，先调用super.clone，然后把结果对象中的所有域都设置成它们的空白状态，然后调
用高层的方法来重新产生对象的状态。
另一个实现对象拷贝的好办法是提供一个拷贝构造器或拷贝工厂。
拷贝构造器只是一个构造器，它唯一的参数类型是包含该构造器的类，如：
public Yum(Yum yum);
拷贝工厂是类似于拷贝构造器的静态工厂：
public static Yum newInstance(Yum yum);
拷贝构造器的做法，及其静态工厂方法的变形，都比Cloneable/clone方法具有更多的优势：它们不依赖于某一种很有
风险、语言之外的对象创建机制；它们不要求遵守尚未制定好文件的规范；它们不会与final域的正常使用发生冲突；
它们不会抛出不必要的受检异常；它们不需要进行类型转换。虽然你不可能把拷贝构造器或静态工厂放到接口中，但是
由于Cloneable接口缺少一个公有的clone方法，所以它了没有提供一个接口该有的功能。因此，使用拷贝构造器或者
拷贝工厂来代替clone方法时，并没有放弃接口的功能特性。
更进一步，拷贝构造器或者拷贝工厂可以带一个参数，参数类型是通过该类实现的接口。例如，按照惯例，所有通用集
合实现都提供了一个拷贝构造器，它的参数类型为Collection或者Map。基于接口的拷贝构造器和拷贝工厂，允许客户
选择拷贝的实现类型，而不是强迫客户接受原始的实现类型。例如，假设你有一个HashSet，并且希望把它拷贝成一个
TreeSet。clone方法无法提供这样的功能，但是转换构造器很容易实现：new TreeSet(s)。
可以肯定的说，其它的接口不应该扩展这个接口，为了继承而设计的类也不应该实现这个接口，由于它具有这么多缺点，
上些专家级的程序员干脆从来不去覆盖clone方法，也从不去调用它，除非拷贝数组。必须清楚一点，对于一个专门为了
继承而设计的类，如果未能提供行为良好的受保护的clone方法，它的子类就不可能实现Cloneable接口。
