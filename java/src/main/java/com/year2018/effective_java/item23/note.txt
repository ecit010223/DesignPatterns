请不要在新代码中使用原生态类型
原提供的类型指没有指定类型参数的的类，如List类，应该指定类型参数，如：List<String>、...
虽然可以将List<String>传递给类型List的参数，但是不能将它传给类型List<Object>的参数。泛型有子类型化的规则，
List<String>是原生态类型List的一个子类型，而不是参数化类型List<Object>的子类型。因此，如果使用像List这
样的原生态类型，就会失掉类型安全性，但是如果使用像List<Object>这样的参数化类型，则不会。
无限制通配类型Set<?>是安全的，原生态类型Set则是不安全的。可以将任何元素放进使用原生态类型的集合中，因此
很容易破坏该集合的类型约束条件；但不能将任何元素（除了null之外）放到Collection<?>中，如果尝试这么做的话，
将会产生一条编译时错误消息。为了防止破坏集合的类型约束条件，不仅无法将任何元素放进Collection<?>中，而且
根本无法猜测你会得到哪种类型的对象。要是无法接受这些限制，就可以使用泛型方法（item27）或者有限制的通配
符类型（item28）。
不要在新代码中使用原生态类型，这条规则有两个小小的例外，两者都源于“泛型信息可以在运行时被擦除”这一事实。
在类文字中必须使用原生态类型，换句话说，List.class、String[].class和int.class都合法，但是
List<String>.class和List<?>.class则不合法。第二个例外与instanceof操作符有关，由于泛型信息可以在运行时
被擦除，因此在参数化类型而非无限制通配符类型上使用instanceof操作符是非法的。用无限制通配符类型代替原生
态类型，对instanceof操作符的行为不产生任何影响，在这种情况下，尖括号（<>）和问号（?）就显得多余了。
if(o instanceof Set){
    Set<?> m = (Set<?>) o;
    ...
}
注意，一旦确定这个o是个Set，就必须将它转换成通配符类型Set<?>，而不是转换成原生态类型Set。这是个受检的转
换，因此不会导致编译时警告。
总结：Set<Object>是个参数化类型，表示可以包含任何对象类型的集合；Set<?>则是一个通配符类型，表示只能包含
某种未知对象类型的一个集合；Set则是个原生态类型，它脱离了泛型系统。前两种安全，最后一种不安全。

