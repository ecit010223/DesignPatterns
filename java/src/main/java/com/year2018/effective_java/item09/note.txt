覆盖equals时总要覆盖hashCode
如果不这样做的话，就会违反Object.hasCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常动作，
这样的集合包括HashMap、HashSet和HashTable.
如下是约定的内容：
1.在应用程序执行期间，只要对象equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，
  hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可
  以不一致。
2.如果两个对象根据equals(Object)方法比较是相等的，那么调用这个对象中任意一个对象的hashCode方法都必须产
  生同样的整数结果。
3.如果两个对象根据equals(Object)方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则
  不一定要产生不同的整数结果。但给不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的
  性能。
理想情况下，散列函数应该把集合中不相等的实例均匀地分布到所有可能的散列值上，要想完全达到这种理想的情形是
非常困难的。幸运的是，相对接近这种理想情形则并不困难，下面给出一种简单的解决办法：
1.把某个非零的常数值，比如说17，保存在一个名为result的int类型的变量中；
2.对于对象中每个关键域f（指equals方法中涉及的每个哉），完成以下步骤：
  a.为该域计算int类型的散列码c：
    i.如果该域是boolean类型，则计算（f?1:0）
    ii.如果该域是byte、char、short或者int类型，则计算(int)f
    iii.如果该域是long类型，则计算(int)(f^(f>>>32))
    iv.如果域是float类型，则计算Float.floatToIntBits(f)
    v.如果该域是double类型，则计算Double.doubleToLongBits(f)，然后按照步骤2.a.ii，为得到的long类型值
      计算散列值
    vi.如果该域是一个对象引用，并且该类的equals方法通过递归调用equals的方式来比较这个域，则同样为这个域
      递归地调用hashCode。如果需要更复杂的比较，则为这个域计算一个“范式”，然后针对这个范式调用hashCode。
      如果这个域的值为null，则返回0
    vii.如果该域是一个数组，则要把每一个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要
      的元素计算一个散列码，然后根据2.b中的做法把这些散列值组合起来。如果数组域中的每个元素都很重要，可
      以利用发行版本1.5中增加的其中一个Array.hashCode方法
  b.按照下面的公式，把步骤2.a中计算得到的散列码c合并到result中
    result = 31*result + c;
3.返回result
4.写完了hashCode方法之后，检测“相等的实例是否都具有相等的散列码”，要编写单元测试来验证你的推断。如果相等
  的实例有着不相等的散列码，则要找出原因，并修正错误。
