复合优先于继承（本条目讨论的问题并不适用于接口继承）
与方法调用不同的是，继承打破了封装性。换句话说，子类依赖于其超类中特定功能的实现细节。超类的实现有可能会
随着发行版本的不同而有所变化，如果真的发生了变化，子类可能会遭到破坏，即使它的代码完成没有改变。因而，子
类必须要跟着超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有很好的文档说明。
复合：不用扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例。因为现有的类变成了新类的一
个组件，新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果，这被称为转发，新类
中的方法被称为转发方法。
只有当子类真正是超类的子类型（subtype)时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在
“is-a”关系的时候，类B才应该扩展类A。如果你打算让类B扩展类A，就应该问问自己：每个B确实也是A吗？如果你不能
够确定这个问题的答案是肯定的，那么B就不应该扩展A。如果答案是否定的，通常情况下，B应该包含A的一个私有实例，
并且暴露一个较小的、较简单的API：A本质上不是B的一部分，只是它的实现细节而已。

