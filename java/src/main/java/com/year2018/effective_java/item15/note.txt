使可变性最小化
不可变类只是其实例不能被修改的类，每个实例中包含的所有信息都必须在创建该实例的时候提供，并在对象的整个生命
周期内固定不变。
为了使类成为不可变，要遵循下面五条规则：
1.不要提供任何会修改对象状态的方法
2.保证类不会被扩展，使这个类成为final的
3.使所有的域都是final的。通过系统的强制方式，可以清楚地表明你的意图。而且，如果一个指向新创建实例的引用在
  缺乏同步机制的情况下，从一个线程被传递到另一个线程，就必须确保正确的行为。
4.使所有的域成为私有的。
5.确保对于任何可变组件的互斥访问。如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象
  的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法中返回该对象引用。在
  构造器、访问方法和readObject方法（见item76）中使用保护性拷贝技术（见item39）
不可变（final）对象本质上是线程安全的，它们不要求同步。当多个线程并发访问这样的对象地，它们不会遭到破坏，
这无疑是获得线程安全最容易的办法。实际上，没有任何线程会注意到其它线程对于不可变对象的影响，所以，不可变
对象可以自由地共享。不可变类应该充分利用这种优势，鼓励客户端尽可能地重用现有的实例，要做到这一点，一个很
简便的办法就是，对于频繁用到的值，为它们提供公有的静态final常量，如Complex.java中的ZERO、ONE、I
这种方法可以被进一步扩展。不可变的类可以提供一些静态工厂（见item01），它们把频繁被请求的实例缓存起来，从
而当现有实例可以符合请求的时候，就不必创建新的实例。
“不可变对象可以被自由地共享”导致的结果是，永远也不需要进行保护性拷贝。因此，不需要，也不应该为不可变的类
提供clone方法或者拷贝构造器。
不仅可以共享不可变对象，甚至也可以共享它们的内部信息。
不可变类真正唯一的缺点是：对于每个不同的值都需要一个单独的对象。
为了确保不可变性，类绝对不允许自身被子类化，除了“使类成为final的”这种方法之外，还有另外一种更加灵活的办
法做到这一点，让不可变的类变成final的另一种办法就是，让类的所有构造器都变成私有的或者包级私有的，并添加
公有的静态工厂来代替公有的构造器。见Complex.java中的构造器、valueOf方法
不可变类的诸多规则指出，没有方法会修改对象，并且它的所有域都必须是final的，实际上，这些规则比真正的要求
更强硬了一点，为了提高性能可以有所放松。事实上应该是这样：没有一个方法能够对对象的状态产生外部可见的改
变。然而，许多不可变的类拥有一个或者多个非final的域，它们在第一次被请求执行这些计算的时候，把一些开销昂
贵的计算结果缓存在这些域中。如果将来再次请求同样的计算，就直接返回这些缓存的值，从而节约了重新计算所需
要的开销。例如，PhoneNumber类中的hashCode（见item09）。
有关序列化功能的一条告诫有必要在这里提出来，如果你选择让自己的不可变类实现Serializable接口，并且它包含
一个或者多个指向可变对象的域，就必须提供一个显式的readObject或者readResolve方法，或者使用
ObjectOutputStream.writeUnshared和ObjectInputStream.readUnshared方法，即使默认的序列化形式是可以接受
的，也是如此，否则攻击者可能从不可变的类创建可变的实例。
总之，坚决不要为每个get方法编写一个相应的set方法，除非有很好的理由要让类成为可变的类，否则就应该是不可变的。
对于有些类而言，其不可变性是不切实际的。如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性。降低对
象可以存在的状态数，可以更容易地分析该对象的行为，同时降低出错的可能性。因此，除非有令人信服的理由要使域
变成非final的，否则要使每个域是final的。
构造器应该创建完全初始化的对象，并建立起所有的约束关系。不要在构造器或者静态工厂之外再提供公有的初始化方
法，除非有令人信服的理由必须这么做。
可以通过TimerTask类来说明这些原则，它是可变的，但是它的状态空间被有意地设计得非常小，你可以创建一个实例，
对它进行调试使它执行起来，也可以随意的取消它，一旦一个定时器任务已经完成，或者已经被取消，就不可能再对它
重新调度。