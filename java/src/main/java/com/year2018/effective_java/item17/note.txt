要么为继承而设计，并提供文档说明，要么就禁止继承
对于为了继承而设计的类，唯一的测试方法就是编写子类。如果遗漏了关键的受保护成员，尝试编写子类就会使遗漏所
带来的痛苦变得更加明显。相反，如果编写了多个子类，并且无一使用受保护的成员，或许就应该把它做成私有的。
为了允许继承，类还必须遵守其它一些约束，构造器决不能调用可被覆盖方法，无论是直接调用还是间接调用。如果违
反了这条规则，很有可能导致程序失败。超类的构造器在子类的构造器之前运行，所以，子类中覆盖版本的方法将会在
子类的构造器运行之前就先被调用。
在为了继承而设计类的时候，Cloneable和Serializable接口出现了特殊的困难。如果类是为了继承而被设计的，无论
实现这其中的哪个接口通常都不是个好主意，因为它们把一些实质的负担转嫁到了扩展这个类的程序员的身上。
如果决定在一个为了继承而设计的类中实现Cloneable或者Serializable接口，就应该意识到，因为clone和
readObject方法在行为上非常类似于构造器，所以类似的限制规则也是适用的：无论是clone还是readObject，都不可
以调用可覆盖的方法，不管是以直接还是间接的方式。对于readObject方法，覆盖版本的方法将在子类的状态被反序列
化之前先被运行；而对于clone方法，覆盖版本的方法则是在子类的clone方法有机会修正被克隆对象的状态之前先被运
行。
如果决定在一个为了继承而设计的类中实现Serializable，并且该类有一个readResolve或者writeReplace方法，就
必须使readResolve或者writeReplace成为受保护的方法，而不是私有的方法。如果这些方法是私有的，那么子类将会
不声不响地忽略掉这两个方法。
对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化。有两种办法可以禁止子类化，比较容易的
办法是把这个类声明为final的，另一种办法是把所有的构造器都变成私有的，或者包级私有的，并增加一些公有的静
态工厂替代构造器。