用enum代替int常量
枚举类型是指由一组固定的常量组成合法值的类型，是通过公有的静态final域为每个枚举常量导出实例的类，因为没有
可以访问的构造器，枚举类型是真正的final，因为客户端即不能创建枚举类型的实例，也不能对它进行扩展，因此很可
能没有实例，而只是声明过的枚举常量。
枚举提供了编译时的类型安全，试图传递类型错误的值给枚举类型中的某个参数时，会导致编译时错误。
包含同名常量的多个枚举类型可以在一个系统中和平共处，因为每个类型都有自己的命名空间。
可以增加或者重新排列枚举类型中的常量，而无需重新编译它的客户端代码，因为导出常量的域在枚举类型和它的客户端
之间提供了一个隔离层：常量值并没有被编译到客户端代码中，而是在int枚举模式之中。
可以通过调用toString方法，返回枚举值的声明名称。
枚举类型还允许添加任意的方法和域，并实现任意的接口。
为什么要将方法或域添加到枚举类型中呢，可以将数据与它的常量关联起来。见Planet.java
枚举天生就是不可变的，因此所有的域都应该为final的，它们可以是公有的，但最好将它们做成是私有的，并提供公有
的访问方法。
如果一个枚举具有普遍适用性，它就应该成为一个顶层类，如果它只是被用在一个特定的顶层类中，它就应该成为该顶
层类的一个成员类。例如，java.math.RoundingMode枚举表示十进制小数的舍入模式，这些舍入模式用于BigDecimal
类，但是它们提供了一个非常有用的抽象，这种抽象本质上又不属于BigDecimal类，通过使用RoundingMode变成一个
顶层类，库的设计者鼓励任何需要舍入模式的程序员重用这个枚举，从而增强API之间的一致性。

Operation.java，将本质上不同的行为与每个常量关联起来。枚举类型有一个自动产生的valueOf(String)方法，它将
常量的名字转变成变量本身，如果在枚举类型中覆盖toString，要考虑编写一个fromString方法，将定制的字符串表示
法变回相应的枚举。试图使每个常量都从自己的构造器将自身放入到map中，会导致编译时错误，就会抛出
NullPointerException。枚举构造器不可以访问枚举的静态域，除了编译时常量域之外，这一限制是有必要的，因为构
造器运行的时候，这些静态域还没有初始化。

PayrollDay.java，特定于常量的方法实现有一个美中不足的地方，它们使得在枚举常量中共享代码变得更加困难。该类
中每当添加一个枚举常量时，就强制选择一种加班报酬策略，它将加班工资计算移到一个私有的嵌套枚举中，将这个策略
枚举的实例传到PayrollDay枚举的构造器中。

